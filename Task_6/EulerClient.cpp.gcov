        -:    0:Source:EulerClient.cpp
        -:    0:Graph:./client-EulerClient.gcno
        -:    0:Data:./client-EulerClient.gcda
        -:    0:Runs:3
        -:    1:#include <iostream>
        -:    2:#include <sstream>
        -:    3:#include <string>
        -:    4:#include <vector>
        -:    5:#include <set>
        -:    6:#include <random>
        -:    7:#include <unistd.h>
        -:    8:#include <netinet/in.h>
        -:    9:#include <arpa/inet.h>
        -:   10:#include <algorithm>
        -:   11:#include <getopt.h>
        -:   12:
        -:   13:constexpr int PORT = 12345;
        -:   14:constexpr const char* SERVER_IP = "127.0.0.1";
        -:   15:constexpr int BUFFER_SIZE = 4096;
        -:   16:
        -:   17:// Build a random simple graph
        3:   18:std::string buildGraphInput(int V, int E, unsigned seed = 42) {
        3:   19:    std::ostringstream out;
        3:   20:    out << V << " " << E << "\n";
        -:   21:
        3:   22:    std::mt19937 rng(seed); // deterministic random generator
        3:   23:    std::uniform_int_distribution<int> dist(0, V - 1);
        -:   24:
        3:   25:    std::set<std::pair<int, int>> edges; // keep track of unique edges
        -:   26:
        -:   27:    // Keep generating random edges until we have exactly E unique ones
       83:   28:    while ((int)edges.size() < E) {
       80:   29:        int u = dist(rng);
       80:   30:        int v = dist(rng);
        -:   31:
      108:   32:        if (u == v) continue; // skip self-loops
        -:   33:
       53:   34:        auto edge = std::minmax(u, v); // store smaller->larger to avoid duplicates
       53:   35:        if (edges.count(edge)) continue; // skip if edge already exists
        -:   36:
       25:   37:        edges.insert(edge);
       25:   38:        out << edge.first << " " << edge.second << "\n";
        -:   39:    }
        -:   40:
        6:   41:    return out.str();
        3:   42:}
        -:   43:
        -:   44:// Usage help
    #####:   45:void printUsage(const char* progName) {
    #####:   46:    std::cerr << "Usage: " << progName << " -v <vertices> -e <edges>\n";
    #####:   47:}
        -:   48:
        3:   49:int main(int argc, char* argv[]) {
        3:   50:    int V = -1, E = -1;
        3:   51:    unsigned seed = 42;
        -:   52:
        -:   53:    // Parse command line arguments
        -:   54:    int opt;
        9:   55:    while ((opt = getopt(argc, argv, "v:e:")) != -1) {
        6:   56:        switch (opt) {
        3:   57:            case 'v':
        3:   58:                V = std::stoi(optarg);
        3:   59:                break;
        3:   60:            case 'e':
        3:   61:                E = std::stoi(optarg);
        3:   62:                break;
    #####:   63:            default:
    #####:   64:                printUsage(argv[0]);
    #####:   65:                return 1;
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:    // Validate arguments
        3:   70:    if (V <= 0 || E < 0 || E > V * (V - 1) / 2) {
    #####:   71:        printUsage(argv[0]);
    #####:   72:        std::cerr << "Invalid arguments: V must be > 0, 0 <= E <= V*(V-1)/2\n";
    #####:   73:        return 1;
        -:   74:    }
        -:   75:
        -:   76:    // Build the random graph input string
        6:   77:    std::string input = buildGraphInput(V, E, seed);
        -:   78:
        -:   79:    // Create socket
        3:   80:    int sock = socket(AF_INET, SOCK_STREAM, 0);
        3:   81:    if (sock < 0) {
    #####:   82:        std::cerr << "Failed to create socket\n";
    #####:   83:        return 1;
        -:   84:    }
        -:   85:
        -:   86:    // Configure server address
        3:   87:    sockaddr_in serverAddr{};
        3:   88:    serverAddr.sin_family = AF_INET;
        3:   89:    serverAddr.sin_port = htons(PORT);
        3:   90:    inet_pton(AF_INET, SERVER_IP, &serverAddr.sin_addr);
        -:   91:
        -:   92:    // Try to connect to the server
        3:   93:    if (connect(sock, (sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
    #####:   94:        std::cerr << "Connection to server failed\n";
    #####:   95:        return 1;
        -:   96:    }
        -:   97:
        3:   98:    std::cout << "Connected to server.\n";
        3:   99:    std::cout << "Graph sent:\n" << input;
        -:  100:
        -:  101:    // Send graph data to the server
        3:  102:    send(sock, input.c_str(), input.size(), 0);
        -:  103:
        -:  104:    // Receive serverâ€™s response
        3:  105:    char buffer[BUFFER_SIZE] = {0};
        3:  106:    int bytesReceived = recv(sock, buffer, sizeof(buffer) - 1, 0);
        3:  107:    if (bytesReceived > 0) {
        3:  108:        std::cout << "Server response:\n" << buffer << "\n";
        -:  109:    } else {
    #####:  110:        std::cerr << "No response from server.\n";
        -:  111:    }
        -:  112:
        -:  113:    // Close the socket and exit
        3:  114:    close(sock);
        3:  115:    return 0;
        -:  116:}
