        -:    0:Source:SCCAlgorithm.cpp
        -:    1:#include "SCCAlgorithm.h"
        -:    2:#include "Graph.h"
        -:    3:#include <vector>
        -:    4:#include <stack>
        -:    5:#include <sstream>
        -:    6:
        -:    7:// DFS to fill finish order (on original graph)
function _ZL8dfsOrderiPKSt6vectorIiSaIiEERS_IcSaIcEERS1_ called 15 returned 100% blocks executed 100%
       15:    8:static void dfsOrder(int u, const std::vector<int>* adj, std::vector<char>& seen, std::vector<int>& order) {
       15:    9:    seen[u] = 1;
call    0 returned 15
       49:   10:    for (int v : adj[u]) {
call    0 returned 15
call    1 returned 15
call    2 returned 34
call    3 returned 34
call    4 returned 49
branch  5 taken 34
branch  6 taken 15 (fallthrough)
       34:   11:        if (!seen[v]) dfsOrder(v, adj, seen, order);
call    0 returned 34
branch  1 taken 12 (fallthrough)
branch  2 taken 22
call    3 returned 12
branch  4 taken 12 (fallthrough)
branch  5 taken 0 (throw)
        -:   12:    }
       15:   13:    order.push_back(u); // finished u
call    0 returned 15
       15:   14:}
        -:   15:
        -:   16:// DFS on the reversed graph, collect one component
function _ZL10dfsCollectiRKSt6vectorIS_IiSaIiEESaIS1_EERS_IcSaIcEERS1_ called 15 returned 100% blocks executed 100%
       15:   17:static void dfsCollect(int u, const std::vector<std::vector<int>>& radj, std::vector<char>& seen, std::vector<int>& comp) {
       15:   18:    seen[u] = 1;
call    0 returned 15
       15:   19:    comp.push_back(u);
call    0 returned 15
       49:   20:    for (int v : radj[u]) {
call    0 returned 15
call    1 returned 15
call    2 returned 15
call    3 returned 34
call    4 returned 34
call    5 returned 49
branch  6 taken 34
branch  7 taken 15 (fallthrough)
       34:   21:        if (!seen[v]) dfsCollect(v, radj, seen, comp);
call    0 returned 34
branch  1 taken 12 (fallthrough)
branch  2 taken 22
call    3 returned 12
branch  4 taken 12 (fallthrough)
branch  5 taken 0 (throw)
        -:   22:    }
       15:   23:}
        -:   24:
function _ZN12SCCAlgorithm3runB5cxx11ERK5Graph called 3 returned 100% blocks executed 76%
        3:   25:std::string SCCAlgorithm::run(const Graph& g) {
        3:   26:    const int n = g.V();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   27:    const std::vector<int>* adj = g.raw();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   28:
        3:   29:    std::ostringstream out;
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   30:    if (n == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   31:        out << "SCC count: 0 (empty graph)";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:   32:        return out.str();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   33:    }
        -:   34:
        -:   35:    // First DFS pass: get vertices in decreasing finish time
        3:   36:    std::vector<char> seen(n, 0);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
        3:   37:    std::vector<int> order;
call    0 returned 3
        3:   38:    order.reserve(n);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   39:
       18:   40:    for (int u = 0; u < n; ++u) {
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       15:   41:        if (!seen[u]) dfsOrder(u, adj, seen, order);
call    0 returned 15
branch  1 taken 3 (fallthrough)
branch  2 taken 12
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
        -:   42:    }
        -:   43:
        -:   44:    // Build reversed graph
        3:   45:    std::vector<std::vector<int>> radj(n);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
       18:   46:    for (int u = 0; u < n; ++u) {
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       49:   47:        for (int v : adj[u]) {
call    0 returned 15
call    1 returned 15
call    2 returned 34
call    3 returned 34
call    4 returned 49
branch  5 taken 34
branch  6 taken 15 (fallthrough)
        -:   48:            // reverse edge v -> u
       34:   49:            radj[v].push_back(u);
call    0 returned 34
call    1 returned 34
branch  2 taken 34 (fallthrough)
branch  3 taken 0 (throw)
        -:   50:        }
        -:   51:    }
        -:   52:
        -:   53:    // Second pass: process in reverse finish order on reversed graph
        3:   54:    std::fill(seen.begin(), seen.end(), 0);
call    0 returned 3
call    1 returned 3
call    2 returned 3
branch  3 taken 3 (fallthrough)
branch  4 taken 0 (throw)
        3:   55:    std::vector<std::vector<int>> components;
call    0 returned 3
        -:   56:
       18:   57:    for (int i = n - 1; i >= 0; --i) {
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       15:   58:        int u = order[i];
call    0 returned 15
       15:   59:        if (!seen[u]) {
call    0 returned 15
branch  1 taken 3 (fallthrough)
branch  2 taken 12
        3:   60:            std::vector<int> comp;
call    0 returned 3
        3:   61:            dfsCollect(u, radj, seen, comp);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   62:            components.push_back(std::move(comp));
call    0 returned 3
call    1 returned 3
branch  2 taken 3 (fallthrough)
branch  3 taken 0 (throw)
        3:   63:        }
call    0 returned 3
call    1 never executed
        -:   64:    }
        -:   65:
        -:   66:    // Format output
        3:   67:    out << "SCC count: " << components.size() << "\n";
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
call    4 returned 3
branch  5 taken 3 (fallthrough)
branch  6 taken 0 (throw)
call    7 returned 3
branch  8 taken 3 (fallthrough)
branch  9 taken 0 (throw)
        6:   68:    for (size_t i = 0; i < components.size(); ++i) {
call    0 returned 6
branch  1 taken 3
branch  2 taken 3 (fallthrough)
        3:   69:        out << "SCC " << i << ": ";
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 3
branch  7 taken 3 (fallthrough)
branch  8 taken 0 (throw)
       18:   70:        for (size_t j = 0; j < components[i].size(); ++j) {
call    0 returned 18
call    1 returned 18
branch  2 taken 15
branch  3 taken 3 (fallthrough)
       15:   71:            out << components[i][j] << (j + 1 == components[i].size() ? "" : " ");
call    0 returned 15
call    1 returned 15
call    2 returned 15
branch  3 taken 15 (fallthrough)
branch  4 taken 0 (throw)
call    5 returned 15
call    6 returned 15
branch  7 taken 3 (fallthrough)
branch  8 taken 12
call    9 returned 15
branch 10 taken 15 (fallthrough)
branch 11 taken 0 (throw)
        -:   72:        }
        3:   73:        out << "\n";
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   74:    }
        3:   75:    return out.str();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   76:}
call    0 returned 3
call    1 returned 3
call    2 returned 3
call    3 returned 3
call    4 returned 3
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
