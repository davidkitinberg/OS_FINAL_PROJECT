        -:    0:Source:HamiltonianAlgorithm.cpp
        -:    1:#include "HamiltonianAlgorithm.h"
        -:    2:#include "Graph.h"
        -:    3:#include <vector>
        -:    4:#include <sstream>
        -:    5:
        -:    6:// Build an adjacency matrix so we can check if an edge exists in O(1).
function _ZL14buildAdjMatrixRK5Graph called 3 returned 100% blocks executed 74%
        3:    7:static std::vector<std::vector<char>> buildAdjMatrix(const Graph& g) {
        3:    8:    int n = g.V();
call    0 returned 3
        3:    9:    const std::vector<int>* adj = g.raw();
call    0 returned 3
        3:   10:    std::vector<std::vector<char>> A(n, std::vector<char>(n, 0));
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 3
call    7 returned 3
call    8 returned 3
call    9 never executed
       18:   11:    for (int u = 0; u < n; ++u) {
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       49:   12:        for (int v : adj[u]) A[u][v] = 1;
call    0 returned 15
call    1 returned 15
call    2 returned 34
call    3 returned 34
call    4 returned 34
call    5 returned 34
call    6 returned 49
branch  7 taken 34
branch  8 taken 15 (fallthrough)
        -:   13:    }
        3:   14:    return A;
        -:   15:}
        -:   16:
        -:   17:// Backtracking helper: try to place vertex at position `pos` in path.
        -:   18:// path[0] is fixed to 0 to avoid counting rotations of the same cycle.
        -:   19:// `used[v]` marks if v is already in the path.
        -:   20:// If we manage to place all vertices and there’s an edge back to the start,
        -:   21:// we’ve found a Hamiltonian cycle.
function _ZL17backtrackHamiltonRKSt6vectorIS_IcSaIcEESaIS1_EERS_IiSaIiEERS1_i called 27 returned 100% blocks executed 79%
       27:   22:static bool backtrackHamilton(
        -:   23:    const std::vector<std::vector<char>>& A,
        -:   24:    std::vector<int>& path,
        -:   25:    std::vector<char>& used,
        -:   26:    int pos
        -:   27:) {
       27:   28:    const int n = (int)A.size();
call    0 returned 27
       27:   29:    if (pos == n) {
branch  0 taken 0 (fallthrough)
branch  1 taken 27
        -:   30:        // All vertices are placed, now check if the last one connects back to 0.
    #####:   31:        return A[path[n - 1]][path[0]] != 0;
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   32:    }
        -:   33:
        -:   34:    // Try every possible next vertex
      135:   35:    for (int v = 1; v < n; ++v) // skip 0 since it's already fixed at start
branch  0 taken 108
branch  1 taken 27 (fallthrough)
        -:   36:    {
      108:   37:        if (!used[v] && A[path[pos - 1]][v]) {
call    0 returned 108
branch  1 taken 60 (fallthrough)
branch  2 taken 48
call    3 returned 60
call    4 returned 60
call    5 returned 60
branch  6 taken 24 (fallthrough)
branch  7 taken 36
branch  8 taken 24 (fallthrough)
branch  9 taken 84
       24:   38:            used[v] = 1;
call    0 returned 24
       24:   39:            path[pos] = v;
call    0 returned 24
      24*:   40:            if (backtrackHamilton(A, path, used, pos + 1)) return true;
call    0 returned 24
branch  1 taken 0 (fallthrough)
branch  2 taken 24
       24:   41:            used[v] = 0; // undo choice if it didn’t work
call    0 returned 24
        -:   42:        }
        -:   43:    }
       27:   44:    return false;
        -:   45:}
        -:   46:
function _ZN20HamiltonianAlgorithm3runB5cxx11ERK5Graph called 3 returned 100% blocks executed 50%
        3:   47:std::string HamiltonianAlgorithm::run(const Graph& g) {
        3:   48:    std::ostringstream out;
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   49:    const int n = g.V();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   50:
       3*:   51:    if (n == 0) { out << "No Hamiltonian circuit (empty graph)\n"; return out.str(); }
branch  0 taken 0 (fallthrough)
branch  1 taken 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
       3*:   52:    if (n == 1) { out << "Hamiltonian circuit: 0 -> 0\n"; return out.str(); }
branch  0 taken 0 (fallthrough)
branch  1 taken 3
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
        -:   53:
        3:   54:    auto A = buildAdjMatrix(g);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   55:
        -:   56:    // For an undirected Hamiltonian cycle, every vertex should have degree >= 2 (this isn’t a complete test).
        -:   57:    {
        3:   58:        const std::vector<int>* adj = g.raw();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   59:        bool obviouslyNo = false;
       18:   60:        for (int u = 0; u < n; ++u) 
branch  0 taken 15
branch  1 taken 3 (fallthrough)
        -:   61:        {
      15*:   62:            if ((int)adj[u].size() < 1) { obviouslyNo = true; break; }
call    0 returned 15
branch  1 taken 0 (fallthrough)
branch  2 taken 15
        -:   63:        }
        3:   64:        if (obviouslyNo) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   65:            out << "No Hamiltonian circuit\n";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:   66:            return out.str();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   67:        }
        -:   68:    }
        -:   69:
        3:   70:    std::vector<int> path(n, -1);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
        3:   71:    std::vector<char> used(n, 0);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
        -:   72:
        3:   73:    path[0] = 0; // Fix start to 0 (break rotational symmetry)
call    0 returned 3
        3:   74:    used[0] = 1;
call    0 returned 3
        -:   75:
        3:   76:    if (backtrackHamilton(A, path, used, 1)) {
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
branch  3 taken 0 (fallthrough)
branch  4 taken 3
    #####:   77:        out << "Hamiltonian circuit: ";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:   78:        for (int i = 0; i < n; ++i) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####:   79:            out << path[i] << " ";
call    0 never executed
call    1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed (throw)
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -:   80:        }
    #####:   81:        out << "0\n"; // close the cycle by returning to the start
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   82:    } else {
        3:   83:        out << "No Hamiltonian circuit\n";
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        -:   84:    }
        3:   85:    return out.str();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   86:}
call    0 returned 3
call    1 returned 3
call    2 returned 3
call    3 returned 3
call    4 never executed
call    5 never executed
call    6 never executed
call    7 never executed
