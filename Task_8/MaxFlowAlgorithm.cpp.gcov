        -:    0:Source:MaxFlowAlgorithm.cpp
        -:    1:#include "MaxFlowAlgorithm.h"
        -:    2:#include "Graph.h"
        -:    3:
        -:    4:#include <vector>
        -:    5:#include <queue>
        -:    6:#include <limits>
        -:    7:#include <sstream>
        -:    8:
function _ZL19edmondsKarp_unitCapRK5Graphii called 3 returned 100% blocks executed 71%
        3:    9:static int edmondsKarp_unitCap(const Graph& G, int s, int t) {
        3:   10:    const int n = G.V();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
       3*:   11:    if (n == 0 || s < 0 || t < 0 || s >= n || t >= n) return 0;
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
branch  4 taken 3 (fallthrough)
branch  5 taken 0
branch  6 taken 3 (fallthrough)
branch  7 taken 0
branch  8 taken 0 (fallthrough)
branch  9 taken 3
       3*:   12:    if (s == t) return 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        -:   13:
        -:   14:    // Build capacity matrix from Graph adjacency: each edge contributes capacity 1
        3:   15:    const std::vector<int>* adj = G.raw();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   16:    std::vector<std::vector<int>> cap(n, std::vector<int>(n, 0));
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 3
call    7 returned 3
call    8 returned 3
call    9 never executed
       18:   17:    for (int u = 0; u < n; ++u) {
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       49:   18:        for (int v : adj[u]) {
call    0 returned 15
call    1 returned 15
call    2 returned 34
call    3 returned 49
branch  4 taken 34
branch  5 taken 15 (fallthrough)
        -:   19:            // parallel edges sum capacities
       34:   20:            ++cap[u][v];
call    0 returned 34
call    1 returned 34
call    2 returned 34
        -:   21:        }
        -:   22:    }
        -:   23:
        3:   24:    int maxflow = 0;
        3:   25:    std::vector<int> parent(n, -1);
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
        -:   26:
function _ZZL19edmondsKarp_unitCapRK5GraphiiENKUliiE_clEii called 8 returned 100% blocks executed 82%
        8:   27:    auto bfs = [&](int source, int sink) -> int {
        8:   28:        std::fill(parent.begin(), parent.end(), -1);
call    0 returned 8
call    1 returned 8
call    2 returned 8
branch  3 taken 8 (fallthrough)
branch  4 taken 0 (throw)
        8:   29:        parent[source] = -2;  // sentinel
call    0 returned 8
        8:   30:        std::queue<std::pair<int,int>> q; // (vertex, bottleneck so far)
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
        8:   31:        q.push({source, std::numeric_limits<int>::max()});
call    0 returned 8
call    1 returned 8
call    2 returned 8
branch  3 taken 8 (fallthrough)
branch  4 taken 0 (throw)
        -:   32:
       19:   33:        while (!q.empty()) {
call    0 returned 19
branch  1 taken 16
branch  2 taken 3 (fallthrough)
       16:   34:            int u = q.front().first;
call    0 returned 16
       16:   35:            int flow_so_far = q.front().second;
call    0 returned 16
       16:   36:            q.pop();
call    0 returned 16
        -:   37:
       91:   38:            for (int v = 0; v < n; ++v) {
branch  0 taken 80
branch  1 taken 11 (fallthrough)
       80:   39:                if (parent[v] == -1 && cap[u][v] > 0) {
call    0 returned 80
branch  1 taken 48 (fallthrough)
branch  2 taken 32
call    3 returned 48
call    4 returned 48
branch  5 taken 21 (fallthrough)
branch  6 taken 27
branch  7 taken 21 (fallthrough)
branch  8 taken 59
       21:   40:                    parent[v] = u;
call    0 returned 21
       21:   41:                    int new_flow = std::min(flow_so_far, cap[u][v]);
call    0 returned 21
call    1 returned 21
call    2 returned 21
       21:   42:                    if (v == sink) return new_flow;
branch  0 taken 5 (fallthrough)
branch  1 taken 16
       16:   43:                    q.push({v, new_flow});
call    0 returned 16
call    1 returned 16
branch  2 taken 16 (fallthrough)
branch  3 taken 0 (throw)
        -:   44:                }
        -:   45:            }
        -:   46:        }
        3:   47:        return 0; // no augmenting path
       11:   48:    };
call    0 returned 8
call    1 never executed
        -:   49:
        -:   50:    while (true) {
        8:   51:        int aug = bfs(s, t);
call    0 returned 8
branch  1 taken 8 (fallthrough)
branch  2 taken 0 (throw)
        8:   52:        if (aug == 0) break; // no more augmenting paths
branch  0 taken 3 (fallthrough)
branch  1 taken 5
        -:   53:
        5:   54:        maxflow += aug;
        -:   55:        // backtrack and update residual capacities
        5:   56:        int v = t;
       12:   57:        while (v != s) {
branch  0 taken 7
branch  1 taken 5 (fallthrough)
        7:   58:            int u = parent[v];
call    0 returned 7
        7:   59:            cap[u][v] -= aug;
call    0 returned 7
call    1 returned 7
        7:   60:            cap[v][u] += aug;
call    0 returned 7
call    1 returned 7
        7:   61:            v = u;
        -:   62:        }
        5:   63:    }
        -:   64:
        3:   65:    return maxflow;
        3:   66:}
call    0 returned 3
call    1 returned 3
call    2 never executed
call    3 never executed
        -:   67:
function _ZN16MaxFlowAlgorithm3runB5cxx11ERK5Graph called 3 returned 100% blocks executed 68%
        3:   68:std::string MaxFlowAlgorithm::run(const Graph& g) {
        3:   69:    std::ostringstream out;
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   70:    const int n = g.V();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   71:    if (n <= 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   72:        out << "Max flow (0->" << n-1 << ", unit capacities): 0\n";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
branch  7 never executed (fallthrough)
branch  8 never executed (throw)
    #####:   73:        return out.str();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   74:    }
        -:   75:
        3:   76:    int flow = edmondsKarp_unitCap(g, 0, n-1); // (graph,source,sink)
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   77:    out << "Max flow (0->" << (n-1) << ", unit capacities): " << flow << "\n";
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 3
branch  7 taken 3 (fallthrough)
branch  8 taken 0 (throw)
call    9 returned 3
branch 10 taken 3 (fallthrough)
branch 11 taken 0 (throw)
call   12 returned 3
branch 13 taken 3 (fallthrough)
branch 14 taken 0 (throw)
        3:   78:    return out.str();
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0 (throw)
        3:   79:}
call    0 returned 3
call    1 never executed
