        -:    0:Source:Client.cpp
        -:    0:Graph:client-Client.gcno
        -:    0:Data:client-Client.gcda
        -:    0:Runs:2
        -:    1:#include <iostream>
        -:    2:#include <sstream>
        -:    3:#include <string>
        -:    4:#include <vector>
        -:    5:#include <set>
        -:    6:#include <random>
        -:    7:#include <cstring>
        -:    8:#include <unistd.h>
        -:    9:#include <netinet/in.h>
        -:   10:#include <arpa/inet.h>
        -:   11:#include <getopt.h>
        -:   12:
        -:   13:constexpr int PORT = 12345;
        -:   14:constexpr const char* SERVER_IP = "127.0.0.1";
        -:   15:constexpr int BUFFER_SIZE = 1 << 16; // 64 KB
        -:   16:
        -:   17:// Generate a random SIMPLE directed edge list (no self-loops, no duplicates).
        -:   18:// The server is expected to know V and E from the request header.
function _ZL14buildEdgesOnlyiij called 10 returned 100% blocks executed 86%
       10:   19:static std::string buildEdgesOnly(int V, int E, unsigned seed) {
       10:   20:    std::ostringstream out;
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10:   21:    std::mt19937 rng(seed); // deterministic RNG with seed
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10:   22:    std::uniform_int_distribution<int> dist(0, V - 1); // pick vertices uniformly
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10:   23:    std::set<std::pair<int,int>> edges; // store unique edges
call    0 returned 10
        -:   24:
        -:   25:    // Keep going until we have E unique directed edges
      120:   26:    while ((int)edges.size() < E) {
call    0 returned 120
branch  1 taken 110
branch  2 taken 10 (fallthrough)
      110:   27:        int u = dist(rng), v = dist(rng);
call    0 returned 110
branch  1 taken 110 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 110
branch  4 taken 110 (fallthrough)
branch  5 taken 0 (throw)
      128:   28:        if (u == v) continue; // skip self-loops
branch  0 taken 27 (fallthrough)
branch  1 taken 83
       83:   29:        auto edge = std::make_pair(u, v); // keep directed edge (u->v)
call    0 returned 83
branch  1 taken 83 (fallthrough)
branch  2 taken 0 (throw)
       83:   30:        if (edges.count(edge)) continue; // skip duplicates
call    0 returned 83
branch  1 taken 83 (fallthrough)
branch  2 taken 0 (throw)
branch  3 taken 18 (fallthrough)
branch  4 taken 65
       65:   31:        edges.insert(edge);
call    0 returned 65
branch  1 taken 65 (fallthrough)
branch  2 taken 0 (throw)
       65:   32:        out << u << " " << v << "\n"; // write edge to output
call    0 returned 65
branch  1 taken 65 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 65
branch  4 taken 65 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 65
branch  7 taken 65 (fallthrough)
branch  8 taken 0 (throw)
call    9 returned 65
branch 10 taken 65 (fallthrough)
branch 11 taken 0 (throw)
        -:   33:    }
       20:   34:    return out.str();
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10:   35:}
call    0 returned 10
call    1 returned 10
call    2 never executed
call    3 never executed
        -:   36:
        -:   37:// Helper function that ensures we send ALL bytes
function _ZL7sendAlliRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 12 returned 100% blocks executed 90%
       12:   38:static bool sendAll(int sock, const std::string& s) {
       12:   39:    const char* p = s.c_str();
call    0 returned 12
       12:   40:    size_t left = s.size();
call    0 returned 12
       24:   41:    while (left > 0) {
branch  0 taken 12
branch  1 taken 12 (fallthrough)
       12:   42:        ssize_t n = ::send(sock, p, left, 0);
call    0 returned 12
      12*:   43:        if (n <= 0) return false;
branch  0 taken 0 (fallthrough)
branch  1 taken 12
       12:   44:        p += n; left -= (size_t)n;
        -:   45:    }
       12:   46:    return true;
        -:   47:}
        -:   48:
        -:   49:// Receive one chunk from the server (single recv).
function _ZL8recvOnceiRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 10 returned 100% blocks executed 88%
       10:   50:static bool recvOnce(int sock, std::string& out) {
        -:   51:    char buf[BUFFER_SIZE];
       10:   52:    int n = ::recv(sock, buf, sizeof(buf)-1, 0);
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
      10*:   53:    if (n <= 0) return false;
branch  0 taken 0 (fallthrough)
branch  1 taken 10
       10:   54:    buf[n] = '\0';
       10:   55:    out.assign(buf, n);
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10:   56:    return true;
        -:   57:}
        -:   58:
        -:   59:// Print usage instructions to stderr
function _ZL5usagePKc called 0 returned 0% blocks executed 0%
    #####:   60:static void usage(const char* prog) {
    #####:   61:    std::cerr << "Usage: " << prog << " -v <vertices> -e <edges> [-s <seed>]\n";
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   62:}
        -:   63:
function main called 2 returned 100% blocks executed 61%
        2:   64:int main(int argc, char* argv[]) {
        2:   65:    int V = -1, E = -1;
        2:   66:    unsigned seed = 42;
        -:   67:
        -:   68:    // Parse command-line options: -v, -e, -s
        -:   69:    int opt;
        6:   70:    while ((opt = getopt(argc, argv, "v:e:s:")) != -1) {
call    0 returned 6
branch  1 taken 4
branch  2 taken 2 (fallthrough)
        4:   71:        switch (opt) {
branch  0 taken 2
branch  1 taken 2
branch  2 taken 0
branch  3 taken 0
        6:   72:            case 'v': V = std::stoi(optarg); break;
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 2
call    7 never executed
        6:   73:            case 'e': E = std::stoi(optarg); break;
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 2
call    7 never executed
    #####:   74:            case 's': seed = (unsigned)std::stoul(optarg); break;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
call    3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed (throw)
call    6 never executed
call    7 never executed
    #####:   75:            default: usage(argv[0]); return 1;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   76:        }
        -:   77:    }
       2*:   78:    if (V <= 0 || E < 0) { usage(argv[0]); return 1; }
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
call    4 never executed
branch  5 never executed (fallthrough)
branch  6 never executed (throw)
        -:   79:
        -:   80:    // Connect once (persistent)
        2:   81:    int sock = ::socket(AF_INET, SOCK_STREAM, 0);
call    0 returned 2
       2*:   82:    if (sock < 0) { std::cerr << "socket failed\n"; return 1; }
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
branch  3 never executed (fallthrough)
branch  4 never executed (throw)
        -:   83:
        2:   84:    sockaddr_in addr{}; addr.sin_family = AF_INET; addr.sin_port = htons(PORT);
        2:   85:    if (::inet_pton(AF_INET, SERVER_IP, &addr.sin_addr) <= 0) {
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:   86:        std::cerr << "bad server ip\n"; return 1;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   87:    }
        2:   88:    if (::connect(sock, (sockaddr*)&addr, sizeof(addr)) < 0) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
branch  3 taken 0 (fallthrough)
branch  4 taken 2
    #####:   89:        std::cerr << "connect failed\n"; return 1;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   90:    }
        -:   91:
        2:   92:    std::cout << "Connected to server " << SERVER_IP << ":" << PORT << "\n";
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 2
branch  7 taken 2 (fallthrough)
branch  8 taken 0 (throw)
call    9 returned 2
branch 10 taken 2 (fallthrough)
branch 11 taken 0 (throw)
call   12 returned 2
branch 13 taken 2 (fallthrough)
branch 14 taken 0 (throw)
        2:   93:    std::cout << "Enter algorithm name (euler|mst|scc|maxflow|hamilton), or 'quit' to exit.\n";
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:   94:
        2:   95:    std::string algo;
call    0 returned 2
call    1 never executed
        -:   96:    while (true) {
       12:   97:        std::cout << "> ";
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0 (throw)
      12*:   98:        if (!std::getline(std::cin, algo)) break;
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 12
branch  4 taken 12 (fallthrough)
branch  5 taken 0 (throw)
branch  6 taken 0 (fallthrough)
branch  7 taken 12
        -:   99:
        -:  100:        // trim leading/trailing spaces
      12*:  101:        while (!algo.empty() && isspace((unsigned char)algo.back())) algo.pop_back();
call    0 never executed
call    1 returned 12
branch  2 taken 12 (fallthrough)
branch  3 taken 0
call    4 returned 12
branch  5 taken 0 (fallthrough)
branch  6 taken 12
branch  7 taken 0
branch  8 taken 12 (fallthrough)
      12*:  102:        size_t i = 0; while (i < algo.size() && isspace((unsigned char)algo[i])) ++i;
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0
call    3 returned 12
branch  4 taken 12 (fallthrough)
branch  5 taken 0 (throw)
branch  6 taken 0 (fallthrough)
branch  7 taken 12
branch  8 taken 0
branch  9 taken 12 (fallthrough)
       12:  103:        algo = algo.substr(i);
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 12
call    4 returned 12
      12*:  104:        if (algo.empty()) continue;
call    0 returned 12
branch  1 taken 0 (fallthrough)
branch  2 taken 12
        -:  105:
        -:  106:        // If user wants to quit, notify server and break
       12:  107:        if (algo == "quit" || algo == "QUIT" || algo == "Quit") {
call    0 returned 12
branch  1 taken 12 (fallthrough)
branch  2 taken 0 (throw)
branch  3 taken 10 (fallthrough)
branch  4 taken 2
call    5 returned 10
branch  6 taken 10 (fallthrough)
branch  7 taken 0 (throw)
branch  8 taken 10 (fallthrough)
branch  9 taken 0
call   10 returned 10
branch 11 taken 10 (fallthrough)
branch 12 taken 0 (throw)
branch 13 taken 0 (fallthrough)
branch 14 taken 10
branch 15 taken 2 (fallthrough)
branch 16 taken 10
       4*:  108:            if (!sendAll(sock, std::string("quit\n"))) std::cerr << "send failed\n";
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 2
branch  7 taken 0 (fallthrough)
branch  8 taken 2
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
call   12 never executed
        2:  109:            break;
        -:  110:        }
        -:  111:
        -:  112:        // Build a new set of E edges
       10:  113:        std::string edges = buildEdgesOnly(V, E, seed++);
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10:  114:        std::ostringstream req;
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       10:  115:        req << algo << " " << V << " " << E << "\n" << edges;
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 10
branch  4 taken 10 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 10
branch  7 taken 10 (fallthrough)
branch  8 taken 0 (throw)
call    9 returned 10
branch 10 taken 10 (fallthrough)
branch 11 taken 0 (throw)
call   12 returned 10
branch 13 taken 10 (fallthrough)
branch 14 taken 0 (throw)
call   15 returned 10
branch 16 taken 10 (fallthrough)
branch 17 taken 0 (throw)
call   18 returned 10
branch 19 taken 10 (fallthrough)
branch 20 taken 0 (throw)
        -:  116:
        -:  117:        // Send request to server
      10*:  118:        if (!sendAll(sock, req.str())) { std::cerr << "send failed\n"; break; }
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 10
branch  4 taken 10 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 10
branch  7 taken 0 (fallthrough)
branch  8 taken 10
call    9 never executed
branch 10 never executed (fallthrough)
branch 11 never executed (throw)
call   12 never executed
        -:  119:        
        -:  120:        // Wait for server response and print it.
       10:  121:        std::string resp;
call    0 returned 10
      10*:  122:        if (!recvOnce(sock, resp)) { std::cerr << "server closed or recv failed\n"; break; }
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
branch  3 taken 0 (fallthrough)
branch  4 taken 10
call    5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed (throw)
       10:  123:        std::cout << resp;
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0 (throw)
       20:  124:    }
call    0 returned 10
branch  1 taken 10 (fallthrough)
branch  2 taken 0
call    3 returned 10
branch  4 taken 10 (fallthrough)
branch  5 taken 0
call    6 returned 10
branch  7 taken 10 (fallthrough)
branch  8 taken 0
call    9 never executed
call   10 never executed
call   11 never executed
        -:  125:
        2:  126:    ::close(sock); // Close socket before exiting
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:  127:    return 0;
call    0 returned 2
        -:  128:}
