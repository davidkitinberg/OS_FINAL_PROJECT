        -:    0:Source:SCCAlgorithm.cpp
        -:    1:#include "SCCAlgorithm.h"
        -:    2:#include "Graph.h"
        -:    3:#include <vector>
        -:    4:#include <stack>
        -:    5:#include <sstream>
        -:    6:
        -:    7:// DFS to fill finish order (on original graph)
function _ZL8dfsOrderiPKSt6vectorIiSaIiEERS_IcSaIcEERS1_ called 10 returned 100% blocks executed 100%
       10:    8:static void dfsOrder(int u, const std::vector<int>* adj, std::vector<char>& seen, std::vector<int>& order) {
       10:    9:    seen[u] = 1;
call    0 returned 10
       23:   10:    for (int v : adj[u]) {
call    0 returned 10
call    1 returned 10
call    2 returned 13
call    3 returned 13
call    4 returned 23
branch  5 taken 13
branch  6 taken 10 (fallthrough)
       13:   11:        if (!seen[v]) dfsOrder(v, adj, seen, order);
call    0 returned 13
branch  1 taken 8 (fallthrough)
branch  2 taken 5
call    3 returned 8
branch  4 taken 8 (fallthrough)
branch  5 taken 0 (throw)
        -:   12:    }
       10:   13:    order.push_back(u); // finished u
call    0 returned 10
       10:   14:}
        -:   15:
        -:   16:// DFS on the reversed graph, collect one component
function _ZL10dfsCollectiRKSt6vectorIS_IiSaIiEESaIS1_EERS_IcSaIcEERS1_ called 10 returned 100% blocks executed 100%
       10:   17:static void dfsCollect(int u, const std::vector<std::vector<int>>& radj, std::vector<char>& seen, std::vector<int>& comp) {
       10:   18:    seen[u] = 1;
call    0 returned 10
       10:   19:    comp.push_back(u);
call    0 returned 10
       23:   20:    for (int v : radj[u]) {
call    0 returned 10
call    1 returned 10
call    2 returned 10
call    3 returned 13
call    4 returned 13
call    5 returned 23
branch  6 taken 13
branch  7 taken 10 (fallthrough)
       13:   21:        if (!seen[v]) dfsCollect(v, radj, seen, comp);
call    0 returned 13
branch  1 taken 3 (fallthrough)
branch  2 taken 10
call    3 returned 3
branch  4 taken 3 (fallthrough)
branch  5 taken 0 (throw)
        -:   22:    }
       10:   23:}
        -:   24:
function _ZN12SCCAlgorithm3runB5cxx11ERK5Graph called 2 returned 100% blocks executed 76%
        2:   25:std::string SCCAlgorithm::run(const Graph& g) {
        2:   26:    const int n = g.V();
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:   27:    const std::vector<int>* adj = g.raw();
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:   28:
        2:   29:    std::ostringstream out;
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:   30:    if (n == 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:   31:        out << "SCC count: 0 (empty graph)";
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
    #####:   32:        return out.str();
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed (throw)
        -:   33:    }
        -:   34:
        -:   35:    // First DFS pass: get vertices in decreasing finish time
        2:   36:    std::vector<char> seen(n, 0);
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 2
        2:   37:    std::vector<int> order;
call    0 returned 2
        2:   38:    order.reserve(n);
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        -:   39:
       12:   40:    for (int u = 0; u < n; ++u) {
branch  0 taken 10
branch  1 taken 2 (fallthrough)
       10:   41:        if (!seen[u]) dfsOrder(u, adj, seen, order);
call    0 returned 10
branch  1 taken 2 (fallthrough)
branch  2 taken 8
call    3 returned 2
branch  4 taken 2 (fallthrough)
branch  5 taken 0 (throw)
        -:   42:    }
        -:   43:
        -:   44:    // Build reversed graph
        2:   45:    std::vector<std::vector<int>> radj(n);
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
       12:   46:    for (int u = 0; u < n; ++u) {
branch  0 taken 10
branch  1 taken 2 (fallthrough)
       23:   47:        for (int v : adj[u]) {
call    0 returned 10
call    1 returned 10
call    2 returned 13
call    3 returned 13
call    4 returned 23
branch  5 taken 13
branch  6 taken 10 (fallthrough)
        -:   48:            // reverse edge v -> u
       13:   49:            radj[v].push_back(u);
call    0 returned 13
call    1 returned 13
branch  2 taken 13 (fallthrough)
branch  3 taken 0 (throw)
        -:   50:        }
        -:   51:    }
        -:   52:
        -:   53:    // Second pass: process in reverse finish order on reversed graph
        2:   54:    std::fill(seen.begin(), seen.end(), 0);
call    0 returned 2
call    1 returned 2
call    2 returned 2
branch  3 taken 2 (fallthrough)
branch  4 taken 0 (throw)
        2:   55:    std::vector<std::vector<int>> components;
call    0 returned 2
        -:   56:
       12:   57:    for (int i = n - 1; i >= 0; --i) {
branch  0 taken 10
branch  1 taken 2 (fallthrough)
       10:   58:        int u = order[i];
call    0 returned 10
       10:   59:        if (!seen[u]) {
call    0 returned 10
branch  1 taken 7 (fallthrough)
branch  2 taken 3
        7:   60:            std::vector<int> comp;
call    0 returned 7
        7:   61:            dfsCollect(u, radj, seen, comp);
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        7:   62:            components.push_back(std::move(comp));
call    0 returned 7
call    1 returned 7
branch  2 taken 7 (fallthrough)
branch  3 taken 0 (throw)
        7:   63:        }
call    0 returned 7
call    1 never executed
        -:   64:    }
        -:   65:
        -:   66:    // Format output
        2:   67:    out << "SCC count: " << components.size() << "\n";
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 2
call    4 returned 2
branch  5 taken 2 (fallthrough)
branch  6 taken 0 (throw)
call    7 returned 2
branch  8 taken 2 (fallthrough)
branch  9 taken 0 (throw)
        9:   68:    for (size_t i = 0; i < components.size(); ++i) {
call    0 returned 9
branch  1 taken 7
branch  2 taken 2 (fallthrough)
        7:   69:        out << "SCC " << i << ": ";
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 7
branch  4 taken 7 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 7
branch  7 taken 7 (fallthrough)
branch  8 taken 0 (throw)
       17:   70:        for (size_t j = 0; j < components[i].size(); ++j) {
call    0 returned 17
call    1 returned 17
branch  2 taken 10
branch  3 taken 7 (fallthrough)
       10:   71:            out << components[i][j] << (j + 1 == components[i].size() ? "" : " ");
call    0 returned 10
call    1 returned 10
call    2 returned 10
branch  3 taken 10 (fallthrough)
branch  4 taken 0 (throw)
call    5 returned 10
call    6 returned 10
branch  7 taken 7 (fallthrough)
branch  8 taken 3
call    9 returned 10
branch 10 taken 10 (fallthrough)
branch 11 taken 0 (throw)
        -:   72:        }
        7:   73:        out << "\n";
call    0 returned 7
branch  1 taken 7 (fallthrough)
branch  2 taken 0 (throw)
        -:   74:    }
        2:   75:    return out.str();
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0 (throw)
        2:   76:}
call    0 returned 2
call    1 returned 2
call    2 returned 2
call    3 returned 2
call    4 returned 2
call    5 never executed
call    6 never executed
call    7 never executed
call    8 never executed
call    9 never executed
